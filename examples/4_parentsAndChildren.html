<!doctype html> 
<meta charset = "utf-8"> 
<title>Keyboard movement</title>
<body>
<script src="../ga.js"></script>
<script>

//Create a new GA instance, and start it.
//Pre-load images in the array.

var g = GA(256, 256, setup, ["images/platforms.png"]);
g.start();

//Declare global sprites, objects, and variables
//that you wnat to access in all the game functions and states

var cat, star, square, message, localMessage, globalMessage;

//A `setup` function that will run only once.
//Use it for intilaization tasks
function setup() {

  //Make the background white and add a border to the canvas
  g.backgroundColor = "white";
  g.canvas.style.border = "1px black dashed";

  //Make a square, position it, and give it a drop shadow
  square = g.rectangle(128, 128, "lightblue", "black", 1);
  square.shadow = true;

  //Use the stage's `put.center` method to put the square
  //in the center of the stage. You can also use `put.top`,
  //`put.right`, `put.bottom` and `put.left`. If you want to offset
  //the position, use x and y offset values as the second and third
  //arguments: `sprite.put.top(anySprite, -10, -5)` 
  g.stage.put.center(square);

  //Make the cat sprite from a tileset
  cat = g.sprite(g.frame("images/platforms.png", 32, 32, 32, 32));
  cat.shadow = true;

  //Add the cat as a child of the square, and put it in the center of
  //the square
  square.addChild(cat);
  square.put.center(cat);

  //Create some text that will display the cat's local position
  localMessage = g.text("", "11px sans-serif", "black");

  //Add the text as a child of the square
  square.addChild(localMessage);

  console.log(localMessage.x)
  //Use the text's `localX` and `localY` values to set its top left
  //corner position relative to the square's top left corner
  localMessage.x = 4;
  localMessage.y = 2;

  //Create some text that will display the cat's global position
  globalMessage = g.text("This is some text to start", "11px sans-serif", "black");
  g.stage.put.bottom(globalMessage, 0, -20);

/*
  //Center the cat
  cat.x = g.canvas.width / 2 - cat.halfWidth;
  cat.y = g.canvas.height / 2 - cat.halfHeight;

  //Make a star
  star = g.sprite(g.frame("images/platforms.png", 32, 0, 32, 32));
  star.x = cat.x;
  star.y = cat.y + cat.height + 12;

  //Make the star a child of the cat
  cat.addChild(star);



  //Check to see what the children of the `stage` and `cat` are
  console.log("g.stage.children: " + g.stage.children);
  console.log("cat.children: " + cat.children);
  //Both the `stage` and `cat` have one child

  //Add the star to the stage
  g.stage.addChild(star);

  //Check to see what the children of the `stage` and `cat` are
  console.log("g.stage.children: " + g.stage.children);
  console.log("cat.children: " + cat.children);
  //The `stage` has 2 children and the `cat` has none

  //Add the star back to the cat
  cat.addChild(star);

  cat.rotation = 0.5;
  */

  //Assign key `press` methods
  g.key.leftArrow.press = function() {
    //Change the cat's velocity when the key is pressed
    cat.vx = -2;
    cat.vy = 0;
  };
  g.key.leftArrow.release = function() {
    //If the left arrow has been released, and the right arrow isn't down,
    //and the cat isn't moving vertically: 
    //Stop the elf and show its `left` state
    if (!g.key.rightArrow.isDown && cat.vy === 0) {
      cat.vx = 0;
    }
  };
  g.key.upArrow.press = function() {
    cat.vy = -2;
    cat.vx = 0;
  };
  g.key.upArrow.release = function() {
    if (!g.key.downArrow.isDown && cat.vx === 0) {
      cat.vy = 0;
    }
  };
  g.key.rightArrow.press = function() {
    cat.vx = 2;
    cat.vy = 0;
  };
  g.key.rightArrow.release = function() {
    if (!g.key.leftArrow.isDown && cat.vy === 0) {
      cat.vx = 0;
    }
  };
  g.key.downArrow.press = function() {
    cat.vy = 2;
    cat.vx = 0;
  };
  g.key.downArrow.release = function() {
    if (!g.key.upArrow.isDown && cat.vx === 0) {
      cat.vy = 0;
    }
  };

  //Add some text to display the side on which
  //the cat is colliding with the edges of the cavnas
  message = g.text("Use the arrow keys to move...", "16px sans-serif", "black");
    
  //Change the state to `play`
  g.state = play;  
}

//The `play` function will run in a loop
function play() {
 
  //Move the cat
  g.move(cat);

  //You can also move a sprite the good old-fashioned way
  //cat.x += cat.vx;
  //cat.y += cat.vy;

  //Display the cat's local `x` and local `y` coordinates. These are
  //relative to the square, which is the cat's parent.
  localMessage.content 
    = "cat.x: " + cat.x + ", " 
    + "cat.y: " + cat.y;

  //Display the cat's global `gx` and global `gy` coordinates. These are
  //relative to the `stage`, which is the root container for all the
  //sprites and groups.
  globalMessage.content 
    = "cat.gx: " + cat.gx + ", " 
    + "cat.gy: " + cat.gy;

  //Contain the cat inside the square's boundary
  var catHitsEdges = g.contain(cat, square.localBounds);

  //Display the edge of canvas that the cat hit
  if (catHitsEdges) {
    message.content 
      = "The cat hit the " + catHitsEdges + " of the square";
  }
  //cat.rotation += 0.01;


  //Contain the cat inside the canvas
  //'contain` constrains the sprite's movement to a rectangular space
  //defined by the last 4 argumants. If the sprite hits the edges of
  //that space, `contain` returns useful a string that will tell you which
  //side the sprite hit: "left", "right". "top" or "bottom".
  /*

  */
}

</script>
</body>

